<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <title>
      Web Serial API
    </title>
    <script class='remove' src='https://www.w3.org/Tools/respec/respec-w3c'
    async></script>
    <script class='remove' src="respecConfig.js"></script>
    <link rel="stylesheet" href="styles/spec.css">
  </head>
  <body>
    <section id='abstract'>
      The <cite>Serial API</cite> provides a way for websites to read and write
      from a serial device through script. Such an API would bridge the web and
      the physical world, by allowing documents to communicate with devices
      such as microcontrollers, 3D printers, and other serial devices. There is
      also a companion <a href=
      "https://github.com/WICG/serial/blob/main/EXPLAINER.md">explainer</a>
      document.
    </section>
    <section id='sotd'>
      This is a work in progress. All <a href=
      "https://github.com/WICG/serial">contributions</a> welcome.
    </section>
    <section data-dfn-for="Navigator">
      <h2>
        Extensions to the {{Navigator}} interface
      </h2>
      <pre class="idl">
    [Exposed=Window, SecureContext]
    partial interface Navigator {
      [SameObject] readonly attribute Serial serial;
    };
      </pre>
      <h3>
        <dfn>serial</dfn> attribute
      </h3>When getting, the {{Navigator/serial}} attribute always returns the
      same instance of the {{Serial}} object.
    </section>
    <section data-dfn-for="WorkerNavigator">
      <h2>
        Extensions to the {{WorkerNavigator}} interface
      </h2>
      <pre class="idl">
    [Exposed=DedicatedWorker, SecureContext]
    partial interface WorkerNavigator {
      [SameObject] readonly attribute Serial serial;
    };
      </pre>
      <h3>
        <dfn>serial</dfn> attribute
      </h3>When getting, the {{WorkerNavigator/serial}} attribute always
      returns the same instance of the {{Serial}} object.
    </section>
    <section data-dfn-for="Serial">
      <h2>
        {{Serial}} interface
      </h2>
      <pre class="idl">
    [Exposed=(DedicatedWorker, Window), SecureContext]
    interface Serial : EventTarget {
      attribute EventHandler onconnect;
      attribute EventHandler ondisconnect;
      Promise&lt;sequence&lt;SerialPort&gt;&gt; getPorts();
      [Exposed=Window] Promise&lt;SerialPort&gt; requestPort(optional SerialPortRequestOptions options = {});
    };
      </pre>
      <section>
        <h3>
          <dfn>requestPort()</dfn> method
        </h3>
        <aside class="example">
          <p>
            When the user first visits a site it will not have permission to
            access any serial devices. A site must first call
            {{Serial/requestPort()}}. This call gives the browser the
            opportunity to prompt the user for which device the site should be
            allowed to control. If the site is designed to work with a
            particular device which is always connected via USB the site can
            provide a filter restricting the devices the user can select to
            only those that would be compatible. For example, a site which
            programs Arduino-powered robots could specify a like the following
            to limit the set of selectable ports to only USB devices with
            Arduino's USB vendor ID,
          </p>
          <pre class="js">
        const filter = { usbVendorId: 0x2341 };
        const port = await navigator.serial.requestPort({ filters: [filter] });
          </pre>
          <p>
            If on the other hand the site expects to be used with a wide
            variety of devices or devices connected through a USB to serial
            converter it may specify no filter at all and rely on the user to
            select the appropriate device,
          </p>
          <pre class="js">
        const port = await navigator.serial.requestPort();
          </pre>
          <p>
            Asking the user to choose a port requires showing a prompt to the
            user and so the site must have [=transient activation=] from
            something like the user clicking a button.
          </p>
          <pre class="html">
        &lt;button id="connect"&gt;Connect&lt;/button&gt;
          </pre>
          <pre class="js">
        const connectButton = document.getElementById("connect");
        connectButton.addEventListener('click', () =&gt; {
          try {
            const port = await navigator.serial.requestPort();
            // Continue connecting to the device attached to |port|.
          } catch (e) {
            // The prompt has been dismissed without selecting a device.
          }
        });
          </pre>
          <p>
            The user may choose not to select a device, in which case the
            {{Promise}} will be rejected with a "{{NotFoundError}}"
            {{DOMException}} that the site must handle.
          </p>
        </aside>
        <p>
          The {{Serial/requestPort()}} method steps are:
        </p>
        <ol>
          <li>Let |promise:Promise| be [=a new promise=].
          </li>
          <li>If [=this=]'s [=relevant global object=]'s [=associated
          Document=] is not [=allowed to use=] the [=policy-controlled
          feature=] named "[=policy-controlled feature/serial=]", [=reject=]
          |promise| with a "{{SecurityError}}" {{DOMException}} and return
          |promise|.
          </li>
          <li>If the [=relevant global object=] of [=this=] does not have
          [=transient activation=], [=reject=] |promise| with a
          "{{SecurityError}}" {{DOMException}} and return |promise|.
          </li>
          <li>If |options|["{{SerialPortRequestOptions/filters}}"] is present,
          then for each |filter:SerialPortFilter| in
          |options|["{{SerialPortRequestOptions/filters}}"] run the following
          steps:
            <ol>
              <li>If |filter|["{{SerialPortFilter/usbVendorId}}"] is not
              present, [=reject=] |promise| with a {{TypeError}} and return
              |promise|.
                <div class="note">
                  This check implements the combined rule that a
                  {{SerialPortFilter}} cannot be empty and if
                  {{SerialPortFilter/usbProductId}} is specified then
                  {{SerialPortFilter/usbVendorId}} must also be specified.
                </div>
              </li>
            </ol>
          </li>
          <li>Run the following steps [=in parallel=]:
            <ol>
              <li>Let |allPorts:list&lt;SerialPort&gt;| be an empty [=list=].
              </li>
              <li>[=list/For each=] paired Bluetooth device:
                <ol>
                  <li>[=list/For each=] {{BluetoothServiceUUID}}
                  |uuid:BluetoothServiceUUID| supported by the device:
                    <ol>
                      <li>If |uuid| is not a [=blocked Bluetooth service class
                      UUID=]:
                        <ul>
                          <li>If |uuid| is equal to the [=Serial Port Profile
                          service class ID=], or
                          </li>
                          <li>
                          |options|["{{SerialPortRequestOptions/allowedBluetoothServiceClassIds}}"]
                          is present and [=list/contains=] |uuid|:
                            <ol>
                              <li>Let |port:SerialPort| be a {{SerialPort}}
                              representing the service on the Bluetooth device.
                              </li>
                              <li>[=list/Append=] |port| to |allPorts|.
                              </li>
                            </ol>
                          </li>
                        </ul>
                      </li>
                    </ol>
                  </li>
                </ol>
              </li>
              <li>[=list/For each=] available non-Bluetooth serial port:
                <ol>
                  <li>Let |port:SerialPort| be a {{SerialPort}} representing
                  the port.
                  </li>
                  <li>[=list/Append=] |port| to |allPorts|.
                  </li>
                </ol>
              </li>
              <li>Prompt the user to grant the site access to a serial port by
              presenting them with a list of ports in |allPorts| that [=match
              any filter=] in |options|["{{SerialPortRequestOptions/filters}}"]
              if present and |allPorts| otherwise.
              </li>
              <li>If the user does not choose a port, [=queue a global task=]
              on the [=relevant global object=] of [=this=] using the [=serial
              port task source=] to [=reject=] |promise| with a
              {{"NotFoundError"}} {{DOMException}} and abort these steps.
              </li>
              <li>Let |port:SerialPort| be a {{SerialPort}} representing the
              port chosen by the user.
              </li>
              <li>[=Queue a global task=] on the [=relevant global object=] of
              [=this=] using the [=serial port task source=] to [=resolve=]
              |promise| with |port|.
              </li>
            </ol>
          </li>
          <li>Return |promise|.
          </li>
        </ol>
        <section data-dfn-for="SerialPortRequestOptions">
          <h4>
            <dfn>SerialPortRequestOptions</dfn> dictionary
          </h4>
          <pre class="idl">
        dictionary SerialPortRequestOptions {
          sequence&lt;SerialPortFilter&gt; filters;
          sequence&lt;BluetoothServiceUUID&gt; allowedBluetoothServiceClassIds;
        };
          </pre>
          <dl>
            <dt>
              <dfn>filters</dfn> member
            </dt>
            <dd>
              Filters for serial ports
            </dd>
            <dt>
              <dfn>allowedBluetoothServiceClassIds</dfn> member
            </dt>
            <dd>
              A list of {{BluetoothServiceUUID}} values representing Bluetooth
              service class IDs. Bluetooth ports with custom service class IDs
              are excluded from the list of ports presented to the user unless
              the service class ID is included in this list.
            </dd>
          </dl>
        </section>
        <section data-dfn-for="SerialPortFilter">
          <h4>
            <dfn>SerialPortFilter</dfn> dictionary
          </h4>
          <pre class="idl">
        dictionary SerialPortFilter {
          unsigned short usbVendorId;
          unsigned short usbProductId;
          BluetoothServiceUUID bluetoothServiceClassId;
        };
          </pre>
          <dl>
            <dt>
              <dfn>usbVendorId</dfn> member
            </dt>
            <dd>
              USB Vendor ID
            </dd>
            <dt>
              <dfn>usbProductId</dfn> member
            </dt>
            <dd>
              USB Product ID
            </dd>
            <dt>
              <dfn>bluetoothServiceClassId</dfn> member
            </dt>
            <dd>
              Bluetooth service class ID
            </dd>
          </dl>
          <p>
            A serial port |port:SerialPort| <dfn>matches the filter</dfn>
            |filter:SerialPortFilter| if these steps return `true`:
          </p>
          <ol>
            <li>Let |info:SerialPortInfo| be the result of calling
            |port|.{{SerialPort/getInfo()}}.
            </li>
            <li>If |filter|["{{SerialPortFilter/bluetoothServiceClassId}}"] is
            present:
              <ol>
                <li>If the serial port is not part of a Bluetooth device,
                return `false`.
                </li>
                <li>If |filter|["{{SerialPortFilter/bluetoothServiceClassId}}"]
                is equal to
                |info|["{{SerialPortInfo/bluetoothServiceClassId}}"], return
                `true`.
                </li>
                <li>Otherwise, return `false`.
                </li>
              </ol>
            </li>
            <li>If |filter|["{{SerialPortFilter/usbVendorId}}"] is not present,
            return `true`.
            </li>
            <li>If the serial port is not part of a USB device, return `false`.
            </li>
            <li>If |info|["{{SerialPortInfo/usbVendorId}}"] is not equal to
            |filter|["{{SerialPortFilter/usbVendorId}}"], return `false`.
            </li>
            <li>If |filter|["{{SerialPortFilter/usbProductId}}"] is not
            present, return `true`.
            </li>
            <li>If |info|["{{SerialPortInfo/usbProductId}}"] is not equal to
            |filter|["{{SerialPortFilter/usbProductId}}"], return `false`.
            </li>
            <li>Otherwise, return `true`.
            </li>
          </ol>
          <p>
            A serial port |port:SerialPort| <dfn data-lt=
            "match any filter">matches any filter</dfn> in a sequence of
            {{SerialPortFilter}} if these steps return `true`:
          </p>
          <ol>
            <li>For each |filter| in the sequence, run these sub-steps:
              <ol>
                <li>If |port| [=matches the filter=] |filter|, return `true`.
                </li>
              </ol>
            </li>
            <li>Return `false`.
            </li>
          </ol>
        </section>
      </section>
      <section>
        <h3>
          <dfn>getPorts()</dfn> method
        </h3>
        <aside class="example">
          <p>
            If a serial port is provided by a USB device then that device may
            be connected or disconnected from the system. Once a site has
            permission to access a port it can receive these events and query
            for the set of connected devices it currently has access to.
          </p>
          <pre class="js">
        // Check to see what ports are available when the page loads.
        document.addEventListener('DOMContentLoaded', async () =&gt; {
          let ports = await navigator.serial.getPorts();
          // Populate the UI with options for the user to select or
          // automatically connect to devices.
        });

        navigator.serial.addEventListener('connect', e =&gt; {
          // Add |e.target| to the UI or automatically connect.
        });

        navigator.serial.addEventListener('disconnect', e =&gt; {
          // Remove |e.target| from the UI. If the device was open the
          // disconnection can also be observed as a stream error.
        });
          </pre>
        </aside>
        <p>
          The {{Serial/getPorts()}} method steps are:
        </p>
        <ol>
          <li>Let |promise:Promise| be [=a new promise=].
          </li>
          <li>If [=this=]'s [=relevant global object=]'s [=associated
          Document=] is not [=allowed to use=] the [=policy-controlled
          feature=] named `"serial"`, [=reject=] |promise| with a
          "{{SecurityError}}" {{DOMException}} and return |promise|.
          </li>
          <li>Run the following steps [=in parallel=]:
            <ol>
              <li>Let |availablePorts| be the sequence of available serial
              ports on the system which the user has allowed the site to access
              as the result of a previous call to {{Serial/requestPort()}}.
              </li>
              <li>Let |ports| be the sequence of the {{SerialPort}}s
              representing the ports in |availablePorts|.
              </li>
              <li>[=Queue a global task=] on the [=relevant global object=] of
              [=this=] using the [=serial port task source=] to [=resolve=]
              |promise| with |ports|.
              </li>
            </ol>
          </li>
          <li>Return |promise|.
          </li>
        </ol>
      </section>
      <section>
        <h3>
          <dfn>onconnect</dfn> attribute
        </h3>{{Serial/onconnect}} is an [=event handler IDL attribute=] for the
        <dfn>connect</dfn> event type.
      </section>
      <section>
        <h3>
          <dfn>ondisconnect</dfn> attribute
        </h3>{{Serial/ondisconnect}} is an [=event handler IDL attribute=] for
        the <dfn>disconnect</dfn> event type.
      </section>
    </section>
    <section data-dfn-for="SerialPort">
      <h2>
        <dfn>SerialPort</dfn> interface
      </h2>
      <pre class="idl">
    [Exposed=(DedicatedWorker,Window), SecureContext]
    interface SerialPort : EventTarget {
      attribute EventHandler onconnect;
      attribute EventHandler ondisconnect;
      readonly attribute ReadableStream readable;
      readonly attribute WritableStream writable;

      SerialPortInfo getInfo();

      Promise&lt;undefined&gt; open(SerialOptions options);
      Promise&lt;undefined&gt; setSignals(optional SerialOutputSignals signals = {});
      Promise&lt;SerialInputSignals&gt; getSignals();
      Promise&lt;undefined&gt; close();
      Promise&lt;undefined&gt; forget();
    };
      </pre>
      <p>
        Methods on this interface typically complete asynchronously, queuing
        work on the <dfn>serial port task source</dfn>.
      </p>
      <p>
        The [=get the parent=] algorithm for {{SerialPort}} returns the same
        {{Serial}} instance that is returned by the {{SerialPort}}'s [=relevant
        global object=]'s {{Navigator}} object's {{Navigator/serial}} getter.
      </p>
      <p>
        Instances of {{SerialPort}} are created with the internal slots
        described in the following table:
      </p>
      <table class="simple" data-dfn-for="SerialPort">
        <tr>
          <th>
            Internal slot
          </th>
          <th>
            Initial value
          </th>
          <th>
            Description (non-normative)
          </th>
        </tr>
        <tr>
          <td>
            <dfn>[[\state]]</dfn>
          </td>
          <td>
            `"closed"`
          </td>
          <td>
            Tracks the active state of the {{SerialPort}}
          </td>
        </tr>
        <tr>
          <td>
            <dfn>[[\bufferSize]]</dfn>
          </td>
          <td>
            undefined
          </td>
          <td>
            The amount of data to buffer for transmit and receive
          </td>
        </tr>
        <tr>
          <td>
            <dfn>[[\readable]]</dfn>
          </td>
          <td>
            `null`
          </td>
          <td>
            A {{ReadableStream}} that receives data from the port
          </td>
        </tr>
        <tr>
          <td>
            <dfn>[[\readFatal]]</dfn>
          </td>
          <td>
            `false`
          </td>
          <td>
            A flag indicating that the port has encountered a fatal read error
          </td>
        </tr>
        <tr>
          <td>
            <dfn>[[\writable]]</dfn>
          </td>
          <td>
            `null`
          </td>
          <td>
            A {{WritableStream}} that transmits data to the port
          </td>
        </tr>
        <tr>
          <td>
            <dfn>[[\writeFatal]]</dfn>
          </td>
          <td>
            `false`
          </td>
          <td>
            A flag indicating that the port has encountered a fatal write error
          </td>
        </tr>
        <tr>
          <td>
            <dfn>[[\pendingClosePromise]]</dfn>
          </td>
          <td>
            `null`
          </td>
          <td>
            A {{Promise}} used to wait for {{SerialPort/readable}} and
            {{SerialPort/writable}} to close
          </td>
        </tr>
      </table>
      <section>
        <h3>
          <dfn>onconnect</dfn> attribute
        </h3>{{SerialPort/onconnect}} is an [=event handler IDL attribute=] for
        the {{connect}} event type.
        <p>
          When a serial port becomes available on the system that the user has
          allowed the site to access as the result of a previous call to
          {{Serial/requestPort()}}, run the following steps:
        </p>
        <ol>
          <li>Let |port:SerialPort| be a {{SerialPort}} representing the port.
          </li>
          <li>[=Fire an event=] named {{connect}} at |port| with its
          {{Event/bubbles}} attribute initialized to `true`.
          </li>
        </ol>
      </section>
      <section>
        <h3>
          <dfn>ondisconnect</dfn> attribute
        </h3>{{SerialPort/ondisconnect}} is an [=event handler IDL attribute=]
        for the {{disconnect}} event type.
        <p>
          When a serial port becomes unavailable on the system that the user
          has allowed the site to access as the result of a previous call to
          {{Serial/requestPort()}}, run the following steps:
        </p>
        <ol>
          <li>Let |port:SerialPort| be a {{SerialPort}} representing the port.
          </li>
          <li>[=Fire an event=] named {{disconnect}} at |port| with its
          {{Event/bubbles}} attribute initialized to `true`.
          </li>
        </ol>
      </section>
      <section>
        <h3>
          <dfn>getInfo()</dfn> method
        </h3>The {{SerialPort/getInfo()}} method steps are:
        <ol>
          <li>Let |info:SerialPortInfo| be a [=new=] {{SerialPortInfo}}
          dictionary.
          </li>
          <li>If the port is part of a USB device, perform the following steps:
            <ol>
              <li>Set |info|["{{SerialPortInfo/usbVendorId}}"] to the vendor ID
              of the device.
              </li>
              <li>Set |info|["{{SerialPortInfo/usbProductId}}"] to the product
              ID of the device.
              </li>
            </ol>
          </li>
          <li>If the port is a service on a Bluetooth device, perform the
          following steps:
            <ol>
              <li>Set |info|["{{SerialPortInfo/bluetoothServiceClassId}}"] to
              the service class UUID of the Bluetooth service.
              </li>
            </ol>
          </li>
          <li>Return |info|.
          </li>
        </ol>
        <section data-dfn-for="SerialPortInfo">
          <h4>
            <dfn>SerialPortInfo</dfn> dictionary
          </h4>
          <pre class="idl">
      dictionary SerialPortInfo {
        unsigned short usbVendorId;
        unsigned short usbProductId;
        BluetoothServiceUUID bluetoothServiceClassId;
      };
          </pre>
          <dl>
            <dt>
              <dfn>usbVendorId</dfn> member
            </dt>
            <dd>
              If the port is part of a USB device this member will be the
              16-bit vendor ID of that device. Otherwise it will be
              `undefined`.
            </dd>
            <dt>
              <dfn>usbProductId</dfn> member
            </dt>
            <dd>
              If the port is part of a USB device this member will be the
              16-bit product ID of that device. Otherwise it will be
              `undefined`.
            </dd>
            <dt>
              <dfn>bluetoothServiceClassId</dfn> member
            </dt>
            <dd>
              If the port is a service on a Bluetooth device this member will
              be a {{BluetoothServiceUUID}} containing the service class UUID.
              Otherwise it will be `undefined`.
            </dd>
          </dl>
        </section>
      </section>
      <section>
        <h3>
          <dfn>open()</dfn> method
        </h3>
        <aside class="example">
          <p>
            Before communicating on a serial port it must be opened. Opening
            the port allows the site to specify the necessary parameters which
            control how data is transmitted and received. Developers should
            check the documentation for the device they are connecting to for
            the appropriate parameters.
          </p>
          <pre class="js">
        await port.open({ baudRate: /* pick your baud rate */ });
          </pre>
          <p>
            Once {{SerialPort/open()}} has resolved the {{SerialPort/readable}}
            and {{SerialPort/writable}} attributes can be accessed to get the
            {{ReadableStream}} and {{WritableStream}} instances for receiving
            data from and sending data to the connected device.
          </p>
        </aside>
        <p>
          The {{SerialPort/open()}} method steps are:
        </p>
        <ol>
          <li>Let |promise| be [=a new promise=].
          </li>
          <li>If [=this=].{{SerialPort/[[state]]}} is not `"closed"`, reject
          |promise| with an "{{InvalidStateError}}" {{DOMException}} and return
          |promise|.
          </li>
          <li>If |options|["{{SerialOptions/dataBits}}"] is not 7 or 8, reject
          |promise| with {{TypeError}} and return |promise|.
          </li>
          <li>If |options|["{{SerialOptions/stopBits}}"] is not 1 or 2, reject
          |promise| with {{TypeError}} and return |promise|.
          </li>
          <li>If |options|["{{SerialOptions/bufferSize}}"] is 0, reject
          |promise| with {{TypeError}} and return |promise|.
          </li>
          <li>Optionally, if |options|["{{SerialOptions/bufferSize}}"] is
          larger than the implementation is able to support, reject |promise|
          with a {{TypeError}} and return |promise|.
          </li>
          <li>Set [=this=].{{SerialPort/[[state]]}} to `"opening"`.
          </li>
          <li>Perform the following steps [=in parallel=].
            <ol>
              <li>Invoke the operating system to open the serial port using the
              connection parameters (or their defaults) specified in |options|.
              </li>
              <li>If this fails for any reason, [=queue a global task=] on the
              [=relevant global object=] of [=this=] using the [=serial port
              task source=] to [=reject=] |promise| with a "{{NetworkError}}"
              {{DOMException}} and abort these steps.
              </li>
              <li>Set [=this=].{{SerialPort/[[state]]}} to `"opened"`.
              </li>
              <li>Set [=this=].{{SerialPort/[[bufferSize]]}} to
              |options|["{{SerialOptions/bufferSize}}"].
              </li>
              <li>[=Queue a global task=] on the [=relevant global object=] of
              [=this=] using the [=serial port task source=] to [=resolve=]
              |promise| with `undefined`.
              </li>
            </ol>
          </li>
          <li>Return |promise|.
          </li>
        </ol>
        <section data-dfn-for="SerialOptions">
          <h4>
            <dfn>SerialOptions</dfn> dictionary
          </h4>
          <pre class="idl">
        dictionary SerialOptions {
          [EnforceRange] required unsigned long baudRate;
          [EnforceRange] octet dataBits = 8;
          [EnforceRange] octet stopBits = 1;
          ParityType parity = "none";
          [EnforceRange] unsigned long bufferSize = 255;
          FlowControlType flowControl = "none";
        };
          </pre>
          <dl>
            <dt>
              <dfn>baudRate</dfn> member
            </dt>
            <dd>
              A positive, non-zero value indicating the baud rate at which
              serial communication should be established.
              <div class="note">
                {{SerialOptions/baudRate}} is the only required member of this
                dictionary. While there are common default for other connection
                parameters it is important for developers to consider and
                consult with the documentation for devices they intend to
                connect to determine the correct values. While some values are
                common there is no standard baud rate. Requiring this parameter
                reduces the potential for confusion if an arbitrary default
                were chosen by this specification.
              </div>
            </dd>
            <dt>
              <dfn>dataBits</dfn> member
            </dt>
            <dd>
              The number of data bits per frame. Either 7 or 8.
            </dd>
            <dt>
              <dfn>stopBits</dfn> member
            </dt>
            <dd>
              The number of stop bits at the end of a frame. Either 1 or 2.
            </dd>
            <dt>
              <dfn>parity</dfn> member
            </dt>
            <dd>
              The parity mode.
            </dd>
            <dt>
              <dfn>bufferSize</dfn> member
            </dt>
            <dd>
              A positive, non-zero value indicating the size of the read and
              write buffers that should be created.
            </dd>
            <dt>
              <dfn>flowControl</dfn> member
            </dt>
            <dd>
              The flow control mode.
            </dd>
          </dl>
          <section data-dfn-for="ParityType">
            <h5>
              <dfn>ParityType</dfn> enum
            </h5>
            <pre class="idl">
          enum ParityType {
            "none",
            "even",
            "odd"
          };
            </pre>
            <dl>
              <dt>
                <dfn>none</dfn>
              </dt>
              <dd>
                No parity bit is sent for each data word.
              </dd>
              <dt>
                <dfn>even</dfn>
              </dt>
              <dd>
                Data word plus parity bit has even parity.
              </dd>
              <dt>
                <dfn>odd</dfn>
              </dt>
              <dd>
                Data word plus parity bit has odd parity.
              </dd>
            </dl>
          </section>
          <section data-dfn-for="FlowControlType">
            <h5>
              <dfn>FlowControlType</dfn> enum
            </h5>
            <pre class="idl">
          enum FlowControlType {
            "none",
            "hardware"
          };
            </pre>
            <dl>
              <dt>
                <dfn>none</dfn>
              </dt>
              <dd>
                No flow control is enabled.
              </dd>
              <dt>
                <dfn>hardware</dfn>
              </dt>
              <dd>
                Hardware flow control using the RTS and CTS signals is enabled.
              </dd>
            </dl>
          </section>
        </section>
      </section>
      <section>
        <h2>
          <dfn>readable</dfn> attribute
        </h2>
        <aside class="example" id="readable-example">
          <p>
            An application receiving data from a serial port will typically use
            a nested pair of loops like this,
          </p>
          <pre class="js">
        while (port.readable) {
          const reader = port.readable.getReader();
          try {
            while (true) {
              const { value, done } = await reader.read();
              if (done) {
                // |reader| has been canceled.
                break;
              }
              // Do something with |value|...
            }
          } catch (error) {
            // Handle |error|...
          } finally {
            reader.releaseLock();
          }
        }
          </pre>
          <p>
            The inner loop will read chunks of data from the port until an
            error is encountered, at which point the code in the "catch" block
            will be executed. The outer loop handles recoverable errors such as
            parity check failures by opening a new reader. Fatal errors will
            cause {{SerialPort/readable}} to become `null` and the loop to end.
          </p>
          <p>
            As long as the serial port is open it can continue to produce data
            and the amount of data in each of the chunks returned by
            {{ReadableStreamDefaultReader/read()}} will be essentially
            arbitrary based on the timing of when it is called. It is up to the
            device and the code communicating with it to decide what
            constitutes a complete message. For example, a device might
            communicate with the host using ASCII-formatted text where each
            message ends with a newline (or the sequence `"\r\n"`). A pipeline
            of {{TransformStream}}s can be used to automatically convert the
            {{Uint8Array}} chunks provided by {{SerialPort/readable}} into
            {{DOMString}}s containing an entire line of text each.
          </p>
          <pre class="js">
        class LineBreakTransformer {
          constructor() {
            this.container = '';
          }

          transform(chunk, controller) {
            this.container += chunk;
            const lines = this.container.split('\r\n');
            this.container = lines.pop();
            lines.forEach(line =&gt; controller.enqueue(line));
          }

          flush(controller) {
            controller.enqueue(this.container);
          }
        }

        const lineReader = port.readable
            .pipeThrough(new TextDecoderStream())
            .pipeThrough(new TransformStream(new LineBreakTransformer()))
            .getReader();
          </pre>
          <p>
            Some other ways of encoding message boundaries are to prefix each
            message with its length or to wait a defined length of time before
            transmitting the next message. Implementing a {{TransformStream}}
            for these types of message boundaries is left as an exercise for
            the reader.
          </p>
          <p>
            While the {{ReadableStreamDefaultReader/read()}} method is
            asynchronous and does not block execution, in code using
            async/await syntax it can seem as if it does. In this situation it
            may be helpful to implement a timeout which will allow the code to
            continue execution if no data is received for a period of time. The
            example below uses the
            {{ReadableStreamDefaultReader/releaseLock()}} method to interrupt a
            call to {{ReadableStreamDefaultReader/read()}} after a timer
            expires. This will not close the stream and so any data received
            after the timeout can still be read later after calling
            {{ReadableStream/getReader()}} again.
          </p>
          <pre class="js">
        async function readWithTimeout(port, timeout) {
          const reader = port.readable.getReader();
          const timer = setTimeout(() =&gt; {
            reader.releaseLock();
          }, timeout);
          const result = await reader.read();
          clearTimeout(timer);
          reader.releaseLock();
          return result;
        }
          </pre>
          <p>
            This feature of {{ReadableStreamDefaultReader/releaseLock()}} was
            added in <a href=
            "https://github.com/whatwg/streams/pull/1168">whatwg/streams#1168</a>
            and has only recently been implemented by browsers.
          </p>
        </aside>
        <p>
          The {{SerialPort/readable}} getter steps are:
        </p>
        <ol>
          <li>If [=this=].{{SerialPort/[[readable]]}} is not `null`, return
          [=this=].{{SerialPort/[[readable]]}}.
          </li>
          <li>If [=this=].{{SerialPort/[[state]]}} is not `"opened"`, return
          `null`.
          </li>
          <li>If [=this=].{{SerialPort/[[readFatal]]}} is `true`, return
          `null`.
          </li>
          <li>Let |stream| be a [=new=] {{ReadableStream}}.
          </li>
          <li>Let |pullAlgorithm| be the following steps:
            <ol>
              <li>Let |desiredSize| be the [=ReadableStream/desired size to
              fill up to the high water mark=] for
              [=this=].{{SerialPort/[[readable]]}}.
              </li>
              <li>If [=this=].{{SerialPort/[[readable]]}}'s
              [=ReadableStream/current BYOB request view=] is non-null, then
              set |desiredSize| to [=this=].{{SerialPort/[[readable]]}}'s
              [=ReadableStream/current BYOB request view=]'s
              [=BufferSource/byte length=].
              </li>
              <li>Run the following steps [=in parallel=]:
                <ol>
                  <li>Invoke the operating system to read up to |desiredSize|
                  bytes from the port, putting the result in the [=byte
                  sequence=] |bytes|.
                    <div class="note">
                      [=this=].{{SerialPort/[[state]]}} becoming `"forgotten"`
                      must be treated as if |the port was disconnected|.
                    </div>
                  </li>
                  <li>[=Queue a global task=] on the [=relevant global object=]
                  of [=this=] using the [=serial port task source=] to run the
                  following steps:
                    <ol>
                      <li>If no errors were encountered, then:
                        <ol>
                          <li>If [=this=].{{SerialPort/[[readable]]}}'s
                          [=ReadableStream/current BYOB request view=] is
                          non-null, then [=ArrayBufferView/write=] |bytes| into
                          [=this=].{{SerialPort/[[readable]]}}'s
                          [=ReadableStream/current BYOB request view=], and set
                          |view| to [=this=].{{SerialPort/[[readable]]}}'s
                          [=ReadableStream/current BYOB request view=].
                          </li>
                          <li>Otherwise, set |view| to the result of
                          [=ArrayBufferView/create|creating=] a {{Uint8Array}}
                          from |bytes| in [=this=]'s [=relevant Realm=].
                          </li>
                          <li>[=ReadableStream/Enqueue=] |view| into
                          [=this=].{{SerialPort/[[readable]]}}.
                          </li>
                        </ol>
                      </li>
                      <li>If a buffer overrun condition was encountered, invoke
                      [=ReadableStream/error=] on
                      [=this=].{{SerialPort/[[readable]]}} with a
                      "<code>BufferOverrunError</code>" {{DOMException}} and
                      invoke the steps to [=handle closing the readable
                      stream=].
                      </li>
                      <li>If a break condition was encountered, invoke
                      [=ReadableStream/error=] on
                      [=this=].{{SerialPort/[[readable]]}} with a
                      "<code>BreakError</code>" {{DOMException}} and invoke the
                      steps to [=handle closing the readable stream=].
                      </li>
                      <li>If a framing error was encountered, invoke
                      [=ReadableStream/error=] on
                      [=this=].{{SerialPort/[[readable]]}} with a
                      "<code>FramingError</code>" {{DOMException}} and invoke
                      the steps to [=handle closing the readable stream=].
                      </li>
                      <li>If a parity error was encountered, invoke
                      [=ReadableStream/error=] on
                      [=this=].{{SerialPort/[[readable]]}} with a
                      "<code>ParityError</code>" {{DOMException}} and invoke
                      the steps to [=handle closing the readable stream=].
                      </li>
                      <li>If an operating system error was encountered, invoke
                      [=ReadableStream/error=] on
                      [=this=].{{SerialPort/[[readable]]}} with an
                      "{{UnknownError}}" {{DOMException}} and invoke the steps
                      to [=handle closing the readable stream=].
                      </li>
                      <li>If |the port was disconnected|, run the following
                      steps:
                        <ol>
                          <li>Set [=this=].{{SerialPort/[[readFatal]]}} to
                          `true`,
                          </li>
                          <li>Invoke [=ReadableStream/error=] on
                          [=this=].{{SerialPort/[[readable]]}} with a
                          "{{NetworkError}}" {{DOMException}}.
                          </li>
                          <li>Invoke the steps to [=handle closing the readable
                          stream=].
                          </li>
                        </ol>
                      </li>
                    </ol>
                  </li>
                </ol>
              </li>
              <li>Return [=a promise resolved with=] `undefined`.
              </li>
            </ol>
            <p class="note">
              The {{Promise}} returned by this algorithm is immediately
              resolved so that it does not block canceling the stream.
              [[STREAMS]] specifies that this algorithm will not be invoked
              again until a chunk is enqueued.
            </p>
          </li>
          <li>Let |cancelAlgorithm| be the following steps:
            <ol>
              <li>Let |promise| be [=a new promise=].
              </li>
              <li>Run the following steps [=in parallel=].
                <ol>
                  <li>Invoke the operating system to discard the contents of
                  all software and hardware receive buffers for the port.
                  </li>
                  <li>[=Queue a global task=] on the [=relevant global object=]
                  of [=this=] using the [=serial port task source=] to run the
                  following steps:
                    <ol>
                      <li>Invoke the steps to [=handle closing the readable
                      stream=].
                      </li>
                      <li>[=Resolve=] |promise| with `undefined`.
                      </li>
                    </ol>
                  </li>
                </ol>
              </li>
              <li>Return |promise|.
              </li>
            </ol>
          </li>
          <li>[=ReadableStream/Set up with byte reading support=] |stream| with
          <i>[=ReadableStream/set up with byte reading
          support/pullAlgorithm=]</i> set to |pullAlgorithm|,
          <i>[=ReadableStream/set up with byte reading
          support/cancelAlgorithm=]</i> set to |cancelAlgorithm|, and
          <i>[=ReadableStream/set up with byte reading
          support/highWaterMark=]</i> set to
          [=this=].{{SerialPort/[[bufferSize]]}}.
          </li>
          <li>Set [=this=].{{SerialPort/[[readable]]}} to |stream|.
          </li>
          <li>Return |stream|.
          </li>
        </ol>To <dfn>handle closing the readable stream</dfn> perform the
        following steps:
        <ol>
          <li>Set [=this=].{{SerialPort/[[readable]]}} to `null`.
          </li>
          <li>If [=this=].{{SerialPort/[[writable]]}} is `null` and
          [=this=].{{SerialPort/[[pendingClosePromise]]}} is not `null`,
          [=resolve=] [=this=].{{SerialPort/[[pendingClosePromise]]}} with
          `undefined`.
          </li>
        </ol>
      </section>
      <section>
        <h3>
          <dfn>writable</dfn> attribute
        </h3>
        <aside class="example">
          <p>
            To write individual chunks of data to the port a
            {{WritableStreamDefaultWriter}} can be created and released as
            necessary. This example uses a `TextEncoder` to encode a
            {{DOMString}} as the necessary {{Uint8Array}} for transmission.
          </p>
          <pre class="js">
        const encoder = new TextEncoder();
        const writer = port.writable.getWriter();
        await writer.write(encoder.encode("PING"));
        writer.releaseLock();
          </pre>
          <p>
            When writing larger chunks it can be important to allow the port to
            apply back pressure so that the serial transmitter does not get too
            far behind sending data generated by the application. The
            {{WritableStreamDefaultWriter/write()}} method returns a
            {{Promise}} which resolves when data has been written. While having
            some data available in the transmit buffer is important to maintain
            good throughput awaiting this {{Promise}} before generating too
            many chunks of data is a good practice to avoid excessive
            buffering.
          </p>
        </aside>
        <p>
          The {{SerialPort/writable}} getter steps are:
        </p>
        <ol>
          <li>If [=this=].{{SerialPort/[[writable]]}} is not `null`, return
          [=this=].{{SerialPort/[[writable]]}}.
          </li>
          <li>If [=this=].{{SerialPort/[[state]]}} is not `"opened"`, return
          `null`.
          </li>
          <li>If [=this=].{{SerialPort/[[writeFatal]]}} is `true`, return
          `null`.
          </li>
          <li>Let |stream:WritableStream| be a [=new=] {{WritableStream}}.
          </li>
          <li>Let |signal:AbortSignal| be |stream|'s [=WritableStream/signal=].
          </li>
          <li>Let |writeAlgorithm| be the following steps, given |chunk|:
            <ol>
              <li>Let |promise:Promise| be [=a new promise=].
              </li>
              <li>Assert: |signal| is not [=AbortSignal/aborted=].
              </li>
              <li>If |chunk| cannot be [=converted to an IDL value=] of type
              {{BufferSource}}, reject |promise| with a {{TypeError}} and
              return |promise|. Otherwise, save the result of the conversion in
              |source:BufferSource|.
              </li>
              <li>[=Get a copy of the buffer source=] |source| and save the
              result in |bytes|.
              </li>
              <li>[=In parallel=], run the following steps:
                <ol>
                  <li>Invoke the operating system to write |bytes| to the port.
                  Alternately, store the chunk for future coalescing.
                    <div class="note">
                      The operating system may return from this operation once
                      |bytes| has been queued for transmission rather than
                      after it has been transmitted.
                    </div>
                    <div class="note">
                      [=this=].{{SerialPort/[[state]]}} becoming `"forgotten"`
                      must be treated as if |the port was disconnected|.
                    </div>
                  </li>
                  <li>[=Queue a global task=] on the [=relevant global object=]
                  of [=this=] using the [=serial port task source=] to run the
                  following steps:
                    <ol>
                      <li>If the chunk was successfully written, or was stored
                      for future coalescing, [=resolve=] |promise| with
                      `undefined`.
                        <div class="note">
                          [[STREAMS]] specifies that |writeAlgorithm| will only
                          be invoked after the {{Promise}} returned by a
                          previous invocation of this algorithm has resolved.
                          For efficiency an implementation is allowed to
                          resolve this {{Promise}} early in order to coalesce
                          multiple chunks waiting in the {{WritableStream}}'s
                          internal queue into a single request to the operating
                          system.
                        </div>
                      </li>
                      <li>If an operating system error was encountered,
                      [=reject=] |promise| with an "{{UnknownError}}"
                      {{DOMException}}.
                      </li>
                      <li>If |the port was disconnected|, run the following
                      steps:
                        <ol>
                          <li>Set [=this=].{{SerialPort/[[writeFatal]]}} to
                          `true`.
                          </li>
                          <li>[=Reject=] |promise| with a "{{NetworkError}}"
                          {{DOMException}}.
                          </li>
                          <li>Invoke the steps to [=handle closing the writable
                          stream=].
                          </li>
                        </ol>
                      </li>
                      <li>If |signal| is [=AbortSignal/aborted=], [=reject=]
                      |promise| with |signal|'s [=AbortSignal/abort reason=].
                      </li>
                    </ol>
                  </li>
                </ol>
              </li>
              <li>Return |promise|.
              </li>
            </ol>
          </li>
          <li>Let |abortAlgorithm| be the following steps:
            <ol>
              <li>Let |promise| be [=a new promise=].
              </li>
              <li>Run the following steps [=in parallel=].
                <ol>
                  <li>Invoke the operating system to discard the contents of
                  all software and hardware transmit buffers for the port.
                  </li>
                  <li>[=Queue a global task=] on the [=relevant global object=]
                  of [=this=] using the [=serial port task source=] to run the
                  following steps:
                    <ol>
                      <li>Invoke the steps to [=handle closing the writable
                      stream=].
                      </li>
                      <li>[=Resolve=] |promise| with `undefined`.
                      </li>
                    </ol>
                  </li>
                </ol>
              </li>
              <li>Return |promise|.
              </li>
            </ol>
          </li>
          <li>Let |closeAlgorithm| be the following steps:
            <ol>
              <li>Let |promise| be [=a new promise=].
              </li>
              <li>Run the following steps [=in parallel=].
                <ol>
                  <li>Invoke the operating system to flush the contents of all
                  software and hardware transmit buffers for the port.
                  </li>
                  <li>[=Queue a global task=] on the [=relevant global object=]
                  of [=this=] using the [=serial port task source=] to run the
                  following steps:
                    <ol>
                      <li>Invoke the steps to [=handle closing the writable
                      stream=].
                      </li>
                      <li>If |signal| is [=AbortSignal/aborted=], [=reject=]
                      |promise| with |signal|'s [=AbortSignal/abort reason=].
                      </li>
                      <li>Otherwise, [=resolve=] |promise| with `undefined`.
                      </li>
                    </ol>
                  </li>
                </ol>
              </li>
              <li>Return |promise|.
              </li>
            </ol>
          </li>
          <li>[=WritableStream/Set up=] |stream| with <a href=
          "https://streams.spec.whatwg.org/#writablestream-set-up-writealgorithm">
            writeAlgorithm</a> set to |writeAlgorithm|, <a href=
            "https://streams.spec.whatwg.org/#writablestream-set-up-abortalgorithm">
            abortAlgorithm</a> set to |abortAlgorithm|, <a href=
            "https://streams.spec.whatwg.org/#writablestream-set-up-closealgorithm">
            closeAlgorithm</a> set to |closeAlgorithm|, <a href=
            "https://streams.spec.whatwg.org/#writablestream-set-up-highwatermark">
            highWaterMark</a> set to [=this=].{{SerialPort/[[bufferSize]]}},
            and <a href=
            "https://streams.spec.whatwg.org/#writablestream-set-up-sizealgorithm">
            sizeAlgorithm</a> set to a byte-counting size algorithm.
          </li>
          <li>[=AbortSignal/Add=] the following abort steps to |signal|:
            <ol>
              <li>Cause any invocation of the operating system to write to the
              port to return as soon as possible no matter how much data has
              been written.
              </li>
            </ol>
          </li>
          <li>Set [=this=].{{SerialPort/[[writable]]}} to |stream|.
          </li>
          <li>Return |stream|.
          </li>
        </ol>To <dfn>handle closing the writable stream</dfn> perform the
        following steps:
        <ol>
          <li>Set [=this=].{{SerialPort/[[writable]]}} to `null`.
          </li>
          <li>If [=this=].{{SerialPort/[[readable]]}} is `null` and
          [=this=].{{SerialPort/[[pendingClosePromise]]}} is not `null`,
          [=resolve=] [=this=].{{SerialPort/[[pendingClosePromise]]}} with
          `undefined`.
          </li>
        </ol>
      </section>
      <section>
        <h3>
          <dfn>setSignals()</dfn> method
        </h3>
        <aside class="example">
          <p>
            Serial ports include a number of additional signals for device
            detection and flow control which can be queried and set explicitly.
            As an example, programming some micro-controllers first requires
            entering a "programming" mode by toggling the "Data Terminal Ready"
            (or DTR) signal.
          </p>
          <pre class="js">
        await port.setSignals({ dataTerminalReady: false });
        await new Promise(resolve =&gt; setTimeout(resolve, 200));
        await port.setSignals({ dataTerminalReady: true });
          </pre>
        </aside>
        <p>
          The {{SerialPort/setSignals()}} method steps are:
        </p>
        <ol>
          <li>Let |promise| be [=a new promise=].
          </li>
          <li>If [=this=].{{SerialPort/[[state]]}} is not `"opened"`, reject
          |promise| with an "{{InvalidStateError}}" {{DOMException}} and return
          |promise|.
          </li>
          <li>If all of the specified members of |signals| are not present
          reject |promise| with {{TypeError}} and return |promise|.
          </li>
          <li>Perform the following steps [=in parallel=]:
            <ol>
              <li>If |signals|["{{SerialOutputSignals/dataTerminalReady}}"] is
              present, invoke the operating system to either assert (if `true`)
              or deassert (if `false`) the "data terminal ready" or "DTR"
              signal on the serial port.
              </li>
              <li>If |signals|["{{SerialOutputSignals/requestToSend}}"] is
              present, invoke the operating system to either assert (if `true`)
              or deassert (if `false`) the "request to send" or "RTS" signal on
              the serial port.
              </li>
              <li>If |signals|["{{SerialOutputSignals/break}}"] is present,
              invoke the operating system to either assert (if `true`) or
              deassert (if `false`) the "break" signal on the serial port.
                <div class="note">
                  The "break" signal is typically implemented as an in-band
                  signal by holding the transmit line at the "mark" voltage and
                  thus prevents data transmission for as long as it remains
                  asserted.
                </div>
              </li>
              <li>If the operating system fails to change the state of any of
              these signals for any reason, [=queue a global task=] on the
              [=relevant global object=] of [=this=] using the [=serial port
              task source=] to reject |promise| with a "{{NetworkError}}"
              {{DOMException}}.
              </li>
              <li>[=Queue a global task=] on the [=relevant global object=] of
              [=this=] using the [=serial port task source=] to [=resolve=]
              |promise| with `undefined`.
              </li>
            </ol>
          </li>
          <li>Return |promise|.
          </li>
        </ol>
        <section data-dfn-for="SerialOutputSignals">
          <h4>
            <dfn>SerialOutputSignals</dfn> dictionary
          </h4>
          <pre class="idl">
        dictionary SerialOutputSignals {
          boolean dataTerminalReady;
          boolean requestToSend;
          boolean break;
        };
          </pre>
          <dl>
            <dt>
              <dfn>dataTerminalReady</dfn>
            </dt>
            <dd>
              Data Terminal Ready (DTR)
            </dd>
            <dt>
              <dfn>requestToSend</dfn>
            </dt>
            <dd>
              Request To Send (RTS)
            </dd>
            <dt>
              <dfn>break</dfn>
            </dt>
            <dd>
              Break
            </dd>
          </dl>
        </section>
      </section>
      <section>
        <h3>
          <dfn>getSignals()</dfn> method
        </h3>The {{SerialPort/getSignals()}} method steps are:
        <ol>
          <li>Let |promise:Promise| be [=a new promise=].
          </li>
          <li>If [=this=].{{SerialPort/[[state]]}} is not `"opened"`, reject
          |promise| with an "{{InvalidStateError}}" {{DOMException}} and return
          |promise|.
          </li>
          <li>Perform the following steps [=in parallel=]:
            <ol>
              <li>Query the operating system for the status of the control
              signals that may be asserted by the device connected to the
              serial port.
              </li>
              <li>If the operating system fails to determine the status of
              these signals for any reason, [=queue a global task=] on the
              [=relevant global object=] of [=this=] using the [=serial port
              task source=] to reject |promise| with a "{{NetworkError}}"
              {{DOMException}} and abort these steps.
              </li>
              <li>Let |signals:SerialInputSignals| be a [=new=]
              {{SerialInputSignals}}.
              </li>
              <li>Set |signals|["{{SerialInputSignals/dataCarrierDetect}}"] to
              `true` if the "data carrier detect" or "DCD" signal has been
              asserted by the device, and `false` otherwise.
              </li>
              <li>Set |signals|["{{SerialInputSignals/clearToSend}}"] to `true`
              if the "clear to send" or "CTS" signal has been asserted by the
              device, and `false` otherwise.
              </li>
              <li>Set |signals|["{{SerialInputSignals/ringIndicator}}"] to
              `true` if the "ring indicator" or "RI" signal has been asserted
              by the device, and `false` otherwise.
              </li>
              <li>Set |signals|["{{SerialInputSignals/dataSetReady}}"] to
              `true` if the "data set ready" or "DSR" signal has been asserted
              by the device, and `false` otherwise.
              </li>
              <li>[=Queue a global task=] on the [=relevant global object=] of
              [=this=] using the [=serial port task source=] to [=resolve=]
              |promise| with |signals|.
              </li>
            </ol>
          </li>
          <li>Return |promise|.
          </li>
        </ol>
        <section data-dfn-for="SerialInputSignals">
          <h4>
            <dfn>SerialInputSignals</dfn> dictionary
          </h4>
          <pre class="idl">
      dictionary SerialInputSignals {
        required boolean dataCarrierDetect;
        required boolean clearToSend;
        required boolean ringIndicator;
        required boolean dataSetReady;
      };
          </pre>
          <dl>
            <dt>
              <dfn>dataCarrierDetect</dfn> member
            </dt>
            <dd>
              Data Carrier Detect (DCD)
            </dd>
            <dt>
              <dfn>clearToSend</dfn> member
            </dt>
            <dd>
              Clear To Send (CTS)
            </dd>
            <dt>
              <dfn>ringIndicator</dfn> member
            </dt>
            <dd>
              Ring Indicator (RI)
            </dd>
            <dt>
              <dfn>dataSetReady</dfn> member
            </dt>
            <dd>
              Data Set Ready (DSR)
            </dd>
          </dl>
        </section>
      </section>
      <section>
        <h3>
          <dfn>close()</dfn> method
        </h3>
        <aside class="example">
          <p>
            When communication with the port is no longer required it can be
            closed and the associated resources released by the system.
          </p>
          <p>
            Calling `port.`{{SerialPort/close()}} implicitly invokes
            `port.`{{SerialPort/readable}}`.`{{ReadableStream/cancel()}} and
            `port.`{{SerialPort/writable}}`.`{{WritableStream/abort()}} in
            order to clear any buffered data. If the application has called
            `port.`{{SerialPort/readable}}`.`{{ReadableStream/getReader()}} or
            `port.`{{SerialPort/writable}}`.`{{WritableStream/getWriter()}} the
            stream is locked and the port cannot be closed. This forces the
            developer to decide how to handle any read or write operations that
            are in progress. For example, to ensure that all buffered data has
            been transmitted before the port is closed the application must
            await the {{Promise}} returned by
            `writer.`{{WritableStreamDefaultWriter/close()}}.
          </p>
          <pre class="js">
        const encoder = new TextEncoder();
        const writer = port.writable.getWriter();
        writer.write(encoder.encode("A long message that will take..."));
        await writer.close();
        await port.close();
          </pre>
          <p>
            To discard any unsent data the application could instead call
            `writer.`{{WritableStreamDefaultWriter/abort()}}.
          </p>
          <p>
            If a {{TransformStream}} is being piped to
            `port`.{{SerialPort/writable}} then waiting for the {{Promise}}
            returned by `writer.`{{WritableStreamDefaultWriter/close()}} to
            resolve is insufficient. The application must wait for the pipe
            chain to close by waiting for the {{Promise}} returned by
            {{ReadableStream/pipeTo()}} to resolve instead.
          </p>
          <pre class="js">
        const encoder = new TextEncoderStream();
        const writableStreamClosed = encoder.readable.pipeTo(port.writable);
        const writer = encoder.writable.getWriter();
        writer.write("A long message that will take...");
        writer.close();
        await writableStreamClosed;
        await port.close();
          </pre>
          <p>
            If a loop is being used to read chunks from the port, as is done in
            [[[#readable-example]]], then it must be exited before calling
            `port.`{{SerialPort/close()}}.
          </p>
          <pre class="js">
        let keepReading = true;
        let reader;

        async function readUntilClosed() {
          while (port.readable &amp;& keepReading) {
            reader = port.readable.getReader();
            try {
              while (true) {
                const { value, done } = await reader.read();
                if (done) {
                  // |reader| has been canceled.
                  break;
                }
                // Do something with |value|...
              }
            } catch (error) {
              // Handle |error|...
            } finally {
              reader.releaseLock();
            }
          }

          await port.close();
        }

        const closed = readUntilClosed();

        // Sometime later...
        keepReading = false;
        reader.cancel();
        await closed;
          </pre>
          <p>
            Calling `reader.`{{ReadableStreamGenericReader/cancel()}} causes
            the call to `reader.`{{ReadableStreamDefaultReader/read()}} to
            return immediately, exiting the inner loop and calling
            `reader.`{{ReadableStreamDefaultReader/releaseLock()}}. The outer
            loop then exits because `keepReading` has been set to `false` and
            with the stream unlocked `port.`{{SerialPort/close()}} can complete
            successfully.
          </p>
          <p>
            While it is also possible to call `port.`{{SerialPort/close()}}
            immediately after awaiting the {{Promise}} returned by
            `reader.`{{ReadableStreamGenericReader/cancel()}} it is better to
            place the call to `port.`{{SerialPort/close()}} as the last step of
            `readUntilClosed()` so that the port is also closed when a fatal
            error is encountered and `port.`{{SerialPort/readable}} becomes
            `null`.
          </p>
        </aside>
        <p>
          The {{SerialPort/close()}} method steps are:
        </p>
        <ol>
          <li>Let |promise| be [=a new promise=].
          </li>
          <li>If [=this=].{{SerialPort/[[state]]}} is not `"opened"`, reject
          |promise| with an "{{InvalidStateError}}" {{DOMException}} and return
          |promise|.
          </li>
          <li>Let |cancelPromise:Promise| be the result of invoking
          [=ReadableStream/cancel=] on [=this=].{{SerialPort/[[readable]]}} or
          [=a promise resolved with=] `undefined` if
          [=this=].{{SerialPort/[[readable]]}} is `null`.
          </li>
          <li>Let |abortPromise:Promise| be the result of invoking
          [=WritableStream/abort=] on [=this=].{{SerialPort/[[writable]]}} or
          [=a promise resolved with=] `undefined` if
          [=this=].{{SerialPort/[[writable]]}} is `null`.
          </li>
          <li>Let |pendingClosePromise| be [=a new promise=].
          </li>
          <li>If [=this=].{{SerialPort/[[readable]]}} and
          [=this=].{{SerialPort/[[writable]]}} are `null`, [=resolve=]
          |pendingClosePromise| with `undefined`.
          </li>
          <li>Set [=this=].{{SerialPort/[[pendingClosePromise]]}} to
          |pendingClosePromise|.
          </li>
          <li>Let |combinedPromise:Promise| be the result of [=getting a
          promise to wait for all=] with «|cancelPromise|, |abortPromise|,
          |pendingClosePromise|».
          </li>
          <li>Set [=this=].{{SerialPort/[[state]]}} to `"closing"`.
          </li>
          <li>[=promise/React=] to |combinedPromise|.
            <ul>
              <li>If |combinedPromise| was fulfilled, then:
                <ol>
                  <li>Run the following steps [=in parallel=]:
                    <ol>
                      <li>Invoke the operating system to close the serial port
                      and release any associated resources.
                      </li>
                      <li>Set [=this=].{{SerialPort/[[state]]}} to `"closed"`.
                      </li>
                      <li>Set [=this=].{{SerialPort/[[readFatal]]}} and
                      [=this=].{{SerialPort/[[writeFatal]]}} to `false`.
                      </li>
                      <li>Set [=this=].{{SerialPort/[[pendingClosePromise]]}}
                      to `null`.
                      </li>
                      <li>[=Queue a global task=] on the [=relevant global
                      object=] of [=this=] using the [=serial port task
                      source=] to [=resolve=] |promise| with `undefined`.
                      </li>
                    </ol>
                  </li>
                </ol>
              </li>
              <li>If |combinedPromise| was rejected with reason |r|, then:
                <ol>
                  <li>Set [=this=].{{SerialPort/[[pendingClosePromise]]}} to
                  `null`.
                  </li>
                  <li>[=Queue a global task=] on the [=relevant global object=]
                  of [=this=] using the [=serial port task source=] to
                  [=reject=] |promise| with |r|.
                  </li>
                </ol>
              </li>
            </ul>
          </li>
          <li>Return |promise|.
          </li>
        </ol>
      </section>
      <section>
        <h3>
          <dfn>forget()</dfn> method
        </h3>
        <aside class="example">
          <p>
            It is posssible to voluntarily revoke a permission to a serial port
            that was granted by a user.
          </p>
          <pre class="js">
        // Request a serial port.
        const port = await navigator.serial.requestPort();

        // Then later... revoke permission to the serial port.
        await port.forget();
          </pre>
        </aside>
        <p>
          The {{SerialPort/forget()}} method steps are:
        </p>
        <ol>
          <li>If the user agent can't perform this action (e.g. permission was
          granted by administrator policy), return [=a promise resolved with=]
          `undefined`.
          </li>
          <li>Run the following steps [=in parallel=]:
            <ol>
              <li>Set [=this=].{{SerialPort/[[state]]}} to `"forgetting"`.
              </li>
              <li>Remove [=this=] from the sequence of available serial ports
              on the system which the user has allowed the site to access as
              the result of a previous call to {{Serial/requestPort()}}.
              </li>
              <li>Set [=this=].{{SerialPort/[[state]]}} to `"forgotten"`.
              </li>
              <li>[=Queue a global task=] on the [=relevant global object=] of
              [=this=] using the [=serial port task source=] to [=resolve=]
              |promise| with `undefined`.
              </li>
            </ol>
          </li>
          <li>Return |promise|.
          </li>
        </ol>
      </section>
    </section>
    <section id="blocklist">
      <h2>
        Blocklist
      </h2>
      <p>
        This specification relies on a blocklist file in the <a href=
        "https://github.com/WICG/serial">https://github.com/WICG/serial</a>
        repository to restrict the set of ports a website can access.
      </p>
      <p>
        The result of <dfn>parsing the Bluetooth service class ID
        blocklist</dfn> at a URL |url| is a [=list=] of {{UUID}} values
        representing custom service IDs.
      </p>
      <p>
        The <dfn>Serial Port Profile service class ID</dfn> is a
        {{BluetoothServiceUUID}} with value
        "`00001101-0000-1000-8000-00805f9b34fb`".
      </p>
      <p>
        A {{BluetoothServiceUUID} |serviceUuid:BluetoothServiceUUID| is a
        <dfn>blocked Bluetooth service class UUID</dfn> if the following steps
        return `true`:
      </p>
      <ol>
        <li>Let |uuid:UUID| be the result of calling
        {{BluetoothUUID}}.{{BluetoothUUID/getService()}} with |serviceUuid|.
        </li>
        <li>Let |blocklist:list&lt;BluetoothServiceUUID&gt;| be the result of
        [=parsing the Bluetooth service class ID blocklist=] at <a href=
        "https://github.com/WICG/serial/blob/main/blocklist.txt">https://github.com/WICG/serial/blob/main/blocklist.txt</a>.
        </li>
        <li>If |blocklist| [=list/contains=] |uuid|, return `true`.
        </li>
        <li>If |uuid| [=string/is=] the [=Serial Port Profile service class
        ID=], return `false`.
        </li>
        <li>If |uuid| [=string/ends with=] "`-0000-1000-8000-00805f9b34fb`",
        return `true`.
        </li>
        <li>Otherwise, return `false`.
        </li>
      </ol>
    </section>
    <section id="integrations">
      <h2>
        Integrations
      </h2>
      <section id="permissions-policy">
        <h3>
          Permissions Policy
        </h3>
        <p>
          This specification defines a feature that controls whether the
          methods exposed by the {{Navigator/serial}} attribute on the
          {{Navigator}} object may be used.
        </p>
        <p>
          The feature name for this feature is "<dfn data-dfn-for=
          "policy-controlled feature"><code>serial</code></dfn>"`.
        </p>
        <p>
          The [=policy-controlled feature/default allowlist=] for this feature
          is `'self'`.
        </p>
      </section>
    </section>
    <section id="security" class="informative">
      <h2>
        Security considerations
      </h2>This API poses similar a security risk to [[?WEB-BLUETOOTH]] and
      [[?WEBUSB]] and so lessons from those are applicable here. The primary
      threats are:
      <ul>
        <li>A malicious site that has tricked the user into granting it access
        to a device using the device's intended capabilities for malicious
        purposes. For example, a robot causing physical damage.
        </li>
        <li>A malicious site that has tricked the user into granting it access
        to a device installing its own firmware into the device in order to
        modify the device's intended capabilities for malicious purposes or to
        attack the host to which it is connected. For example, triggering a
        buffer overflow in other host software which communicates with the
        device.
        </li>
        <li>Malicious code injected into a trusted site which has been granted
        access to the device doing any of the above. For example, an online
        firmware update utility being hacked to deliver malicious firmware.
        </li>
        <li>An attacker convincing the user to connect a malicious device to
        their system which colludes with a malicious or exploited site to
        create a web-based channel for communicating back to the attacker.
        </li>
      </ul>The primary mitigation to all of these attacks is the
      {{Serial/requestPort()}} pattern, which requires user interaction and
      only supports granting access to a single device at a time. This prevents
      drive-by attacks because a site cannot enumerate all connected devices to
      determine whether a vulnerable device exists and must instead proactively
      inform the user that it desires access. Implementations may also provide
      a visual indication that a site is currently communicating with a device
      and controls for revoking that permission at any time.
      <p>
        This specification requires the site to be served from a [=secure
        context=] in order to prevent malicious code from being injected by a
        network-based attacker. This ensures that the site identity shown to
        the user when making permission decisions is accurate. This
        specification also requires top-level documents to opt-in through
        [[?PERMISSIONS-POLICY]] before allowing a cross-origin iframe to use
        the API. When combined with [[?CSP3]] these mechanisms provide
        protection against malicious code injection attacks.
      </p>
      <p>
        The remaining concern is the exploitation of a connected device through
        a phishing attack that convinces the user to grant a malicious site
        access to a device. These attacks can be used to either exploit the
        device’s capabilities as designed or to install malicious firmware on
        the device that will in turn attack the host computer. Host software
        may be vulnerable to attack because it improperly validates input from
        connected devices. Security research in this area has encouraged
        software vendors to treat connected devices as untrustworthy.
      </p>
      <p>
        There is no mechanism that will completely prevent this type of attack
        because data sent from a page to the device is an opaque sequence of
        bytes. Efforts to block a particular type of data from being sent are
        likely be met by workarounds on the part of device manufacturers who
        nevertheless want to send this type of data to their devices.
      </p>
      <p>
        User agents can implement additional mechanisms to control access to
        devices:
      </p>
      <ul>
        <li>A setting which prevents sites from calling
        {{Serial/requestPort()}} unless added to an explicit allow list.
          <p>
            Systems administrators could apply such a setting across their
            managed fleet using enterprise policy controls. Such controls may
            allow the administrator to automatically grant selected sites
            access to particular devices and no others.
          </p>
        </li>
        <li>A list of device IDs for hardware which is known to be exploitable
        could be deployed with the user agent. Connections to listed devices
        would be blocked. An implementation could use its automatic update or
        experiment management system to deploy updates to this list on the fly
        to block an active attack.
        </li>
      </ul>Implementations of [[?WEB-BLUETOOTH]] and [[?WEBUSB]] have
      experimented with these mitigations however there are limits to their
      effectiveness. First, it is difficult to define whether a device is
      exploitable. For example, this API will allow a site to upload firmware
      to a microcontroller development board. This is a key use case for this
      API as these devices are common in the educational and hobbyist markets.
      These boards do not implement firmware signature verification and so can
      easily be turned into a malicious device. These boards are clearly
      exploitable but should not be blocked.
      <p>
        In addition, maintaining a list of vulnerable devices works well for
        USB and Bluetooth because those protocols define out-of-band mechanisms
        to gather device metadata. The make and model of such devices can thus
        be easily identified even if they present themselves to the host as a
        virtual serial ports. However, there are generic USB- or
        Bluetooth-to-serial adapters as well as systems with "real" serial
        ports using a DB-25, DE-9 or RJ-45 connector. For these there is no
        metadata that can be read to determine the identity of the device
        connected to the port and so blocking access to these is not possible.
      </p>
    </section>
    <section id="privacy" class="informative">
      <h2>
        Privacy considerations
      </h2>Serial ports and serial devices contain two kinds of sensitive
      information. When a port is a USB or Bluetooth device there are
      identifiers such as the vendor and product IDs (which identify the make
      and model) as well as a serial number or MAC address. The serial device
      itself may also have its own identifier that is available through
      commands sent via the serial port. The device may also store other
      private information which may or may not be identifying.
      <p>
        In order to manage device permissions an implementation will likely
        store device identifiers such as the USB vendor ID, product ID and
        serial number in its user preferences file to be used as stable
        identifiers for devices the user has granted sites access to. These
        would not be shared directly with sites and would be cleared when
        permission is revoked or site data in general is cleared.
      </p>
      <p>
        Commands a page can send to the device after it has been granted access
        a page may also be able to access any of the other sensitive
        information stored by the device. For the reasons mentioned in
        [[[#security]]] it is impractical and undesirable to attempt to prevent
        a page from accessing this information.
      </p>
      <p>
        Implementations should provide users with complete control over which
        devices a site can access and not grant device access without user
        interaction. This is the intention of the {{Serial/requestPort()}}
        method. This prevents a site from silently enumerating and collecting
        data from all connected devices. This is similar to the file picker UI.
        A site has no knowledge of the filesystem, only the files or
        directories that have been chosen by the user. An implementation could
        notify the user when a site is using these permissions with an
        indicator icon appearing in the tab or address bar.
      </p>
      <p>
        Implementations that provide a "private" or "incognito" browsing mode
        should ensure that permissions from the user's normal profile do not
        carry over to such a session and permissions granted in this session
        are not persisted when the session ends. An implementation may warn the
        user when granting access to a device in such as session as, similar to
        entering identifying information by hand, device identifiers and other
        unique properties available from communicating with the device
        mentioned previously can be used to identify the user between sessions.
      </p>
      <p>
        Users may be surprised by the capabilities granted by this API if they
        do not understand the ways in which granting access to a device breaks
        traditional isolation boundaries in the web security model. Security UI
        and documentation should explain that granting a site access to a
        device could give the site full control over the device and any data
        contained within.
      </p>
    </section>
    <section id="conformance"></section>
    <section class="appendix">
      <h2>
        Acknowledgements
      </h2>The following people contributed to the development of this
      document.
      <ul id="gh-contributors"></ul>
    </section>
  </body>
</html>
